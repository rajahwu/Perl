// Fork of https://github.com/andrejewski/himalaya with tweaks
const { lexer } = require('./lexer')
const { parser } = require('./parser')
const { format } = require('./format')
const { validator } = require('./validate')
const { toHTML } = require('./stringify')
const {
  voidTags,
  closingTags,
  childlessTags,
  closingTagAncestorBreakers
} = require('./tags')
const { findCode, REP_SYMBOL, ARROW_SYMBOL } = require('./utils/find-code')

const parseDefaults = {
  voidTags,
  closingTags,
  childlessTags,
  closingTagAncestorBreakers,
  includePositions: true,
}

// https://regex101.com/r/UeQ049/4
const URL_OR_EMAIL = /(<)(\S*(?:https?:\/\/|[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?))\S*)(>)/g

function formatStr(str) {
  const codeBlocks = findCode(str)
  let newString = str
    // https://regex101.com/r/Kqpl34/1 replace => arrows to avoid attribute collision
    .replace(/(=\{{1,2}\(.*\))(\s*)(\s=>\s)(.*)(})/g, `$1$2${ARROW_SYMBOL}$4$5`)
    // https://regex101.com/r/UeQ049/1 replace <http://inline-urls.com> md links
    // .replace(/<(\S*[@:]\S*)>/g, `[$1]($1)`) // as markdown link
    // https://regex101.com/r/UeQ049/2 replace <http://inline-urls.com> md links
    .replace(URL_OR_EMAIL, `${REP_SYMBOL}$2$3`)
  // console.log('newString', newString)

  for (let index = 0; index < codeBlocks.length; index++) {
    const { block } = codeBlocks[index]
    /* Disable html symbols inside code fences */
    newString = newString.replace(block, block.replace(/</g, REP_SYMBOL))
  }
  
  return newString
    // Fix non html entities in `backticks` https://regex101.com/r/zTMxfT/1
    .replace(/`(<)([^\/][^`\n]*)(>)`/g, `\`${REP_SYMBOL}$2$3\``)
    // Fix non html entities in "double quotes"
    .replace(/"(<)([^\/][^"\n]*)(>)"/g, `"${REP_SYMBOL}$2$3"`)
    // Fix non html entities in 'single quotes'
    .replace(/\'(<)([^\/][^'\n]*)(>)'/g, `'${REP_SYMBOL}$2$3'`)
}

function parse(str = '', opts = {}) {
  const options = Object.assign(parseDefaults, opts)
  /*
  const formattedStr = formatStr(str)
  console.log('formattedStr', formattedStr)
  /** */
  const tokens = lexer(formatStr(str), options)
  const nodes = parser(tokens, options)
  return format(nodes, options, str)
}

function stringify(ast, opts = {}) {
  const options = Object.assign(parseDefaults, opts)
  return toHTML(ast, options)
}

function validate(strOrAst, opts = {}) {
  const ast = (typeof strOrAst === 'string') ? parse(strOrAst) : strOrAst
  const options = Object.assign(parseDefaults, opts)
  return validator(ast, options)
}

module.exports = {
  parseDefaults,
  parse,
  stringify,
  validate
}