"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transform = exports.getTitle = exports.getLinesToToc = exports.countHeaders = exports.getMarkdownHeaders = exports.matchesEnd = exports.matchesStart = void 0;
const anchor_markdown_header_1 = require("@technote-space/anchor-markdown-header");
const update_section_1 = __importDefault(require("update-section"));
const md = __importStar(require("@textlint/markdown-to-ast"));
const get_html_headers_1 = require("./get-html-headers");
const params_1 = require("./params");
const utils_1 = require("./utils");
const __1 = require("..");
const getTargetComments = (checkComments, defaultComments) => {
    if (checkComments.length) {
        return checkComments;
    }
    return [defaultComments];
};
const matchesStart = (checkOpeningComments) => (line) => getTargetComments(checkOpeningComments !== null && checkOpeningComments !== void 0 ? checkOpeningComments : [], __1.CHECK_OPENING_COMMENT).some(comment => new RegExp(comment).test(line));
exports.matchesStart = matchesStart;
const matchesEnd = (checkClosingComments) => (line) => getTargetComments(checkClosingComments !== null && checkClosingComments !== void 0 ? checkClosingComments : [], __1.CHECK_CLOSING_COMMENT).some(comment => new RegExp(comment).test(line));
exports.matchesEnd = matchesEnd;
const addAnchor = (mode, moduleName, header) => {
    return Object.assign(Object.assign({}, header), { anchor: anchor_markdown_header_1.anchor(header.name, mode, header.repetition, moduleName), hash: anchor_markdown_header_1.getUrlHash(header.name, mode, header.repetition, moduleName) });
};
// eslint-disable-next-line no-magic-numbers
const shouldEscape = (header) => /^#+\s+/.test(header.raw) && !/\s+#+$/.test(header.raw) && header.children.length === 1 && header.children[0].type === md.Syntax.Str;
const escapeHeader = (header) => md.parse(header.raw.replace(/^#+\s+/, '').replace('&#035;', '#').replace('#', '&#035;').replace(']', '&#93;').replace('[', '&#91;').trim());
const getMarkdownHeaders = (lines, maxHeaderLevel) => {
    const extractText = (header) => {
        const target = shouldEscape(header) ? escapeHeader(header) : header;
        return target.children
            .map(node => {
            if (node.type === md.Syntax.Link) {
                return extractText(node);
            }
            if (node.type === md.Syntax.Image) {
                // Images (at least on GitHub, untested elsewhere) are given a hyphen
                // in the slug. We can achieve this behavior by adding an '*' to the
                // TOC entry. Think of it as a "magic char" that represents the iamge.
                return '*';
            }
            return node.raw;
        }).join('');
    };
    const toHeader = (header) => !maxHeaderLevel || header.depth <= maxHeaderLevel ? {
        line: header.loc.start.line,
        rank: header.depth,
        name: extractText(header),
    } : null;
    return md.parse(lines.join('\n')).children.filter((node) => node.type === md.Syntax.Header).map(toHeader).filter(item => item !== null);
};
exports.getMarkdownHeaders = getMarkdownHeaders;
const countHeaders = (headers, mode, moduleName) => {
    const repetitions = {};
    return headers.map(header => {
        const name = anchor_markdown_header_1.getUrlHash(header.name, mode, undefined, moduleName);
        if (Object.prototype.hasOwnProperty.call(repetitions, name)) {
            repetitions[name]++;
        }
        else {
            repetitions[name] = 0;
        }
        return Object.assign(Object.assign({}, header), { repetition: repetitions[name] });
    });
};
exports.countHeaders = countHeaders;
const getLinesToToc = (lines, currentToc, info, processAll) => {
    if (processAll || !currentToc) {
        return lines;
    }
    // when updating an existing toc, we only take the headers into account
    // that are below the existing toc
    if (info.hasEnd) {
        // eslint-disable-next-line no-magic-numbers
        return lines.slice(info.endIdx + 1);
    }
    return lines;
};
exports.getLinesToToc = getLinesToToc;
const getTitle = (title, lines, info, startSection, matchesEnd) => {
    if (title) {
        return title;
    }
    if (info.hasStart && lines[info.startIdx + startSection.length].trim()) {
        if (matchesEnd(lines[info.startIdx + startSection.length])) {
            return __1.DEFAULT_TITLE;
        }
        return lines[info.startIdx + startSection.length].trim();
    }
    return __1.DEFAULT_TITLE;
};
exports.getTitle = getTitle;
const wrapTitle = (title, isFolding) => isFolding && title !== '' ? `<summary>${title.replace(/^([*_]*)(.+)\1$/, '$2')}</summary>` : title;
const wrapToc = (toc, title, isFolding) => isFolding && title !== '' ? `<details>\n${toc}\n</details>` : toc;
// Use document context as well as command line args to infer the title
const determineTitle = (title, isNotitle, isFolding, lines, info, startSection, matchesEnd) => {
    if (isNotitle) {
        return '';
    }
    return wrapTitle(exports.getTitle(title, lines, info, startSection, matchesEnd), isFolding);
};
const getHeaderContents = (headers, indentation, lowestRank, entryPrefix) => headers.map(header => getHeaderItem(header, indentation, lowestRank, entryPrefix)).join('\n');
const getHeaderItem = (header, indentation, lowestRank, entryPrefix) => {
    return `${indentation.repeat(header.rank - lowestRank)}${entryPrefix} ${header.anchor}`;
};
const getHtmlHeaderContents = (headers, lowestRank, customTemplate, itemTemplate, separator) => utils_1.replaceVariables(customTemplate !== null && customTemplate !== void 0 ? customTemplate : __1.DEFAULT_CUSTOM_TEMPLATE, [{
        key: 'ITEMS',
        replace: `\n${headers.filter(header => header.rank === lowestRank).map(header => getHeaderItemHtml(header, itemTemplate)).join(`\n${separator !== null && separator !== void 0 ? separator : __1.DEFAULT_SEPARATOR}\n`)}\n`,
    }]);
const getHeaderItemHtml = (header, itemTemplate) => {
    return utils_1.replaceVariables(itemTemplate !== null && itemTemplate !== void 0 ? itemTemplate : __1.DEFAULT_ITEM_TEMPLATE, [
        { key: 'LINK', replace: `#${header.hash}` },
        { key: 'TEXT', replace: header.name },
    ]);
};
const buildToc = (isCustomMode, inferredTitle, linkedHeaders, lowestRank, customTemplate, itemTemplate, separator, indentation, entryPrefix, footer) => inferredTitle + (inferredTitle ? '\n\n' : '\n') +
    (isCustomMode ? getHtmlHeaderContents(linkedHeaders, lowestRank, customTemplate, itemTemplate, separator) : getHeaderContents(linkedHeaders, indentation, lowestRank, entryPrefix)) + '\n' +
    (footer ? `\n${footer}\n` : '');
const getResult = (result) => (Object.assign({ transformed: result.transformed }, (result.transformed ? Object.assign(Object.assign({}, result.result), { reason: '' }) : {
    data: '',
    toc: '',
    wrappedToc: '',
    reason: result.reason,
})));
const transform = (content, options = {}) => {
    const lines = content.split('\n');
    const info = update_section_1.default.parse(lines, exports.matchesStart(options.checkOpeningComments), exports.matchesEnd(options.checkClosingComments));
    const startSection = params_1.getStartSection(lines, info, exports.matchesEnd(options.checkClosingComments));
    const extractedOptions = params_1.extractParams(startSection.join(' '));
    const { mode, moduleName, maxHeaderLevel, title, isNotitle, isFolding, entryPrefix, processAll, updateOnly, openingComment, closingComment, isCustomMode, customTemplate, itemTemplate, separator, footer, } = Object.assign(Object.assign({}, options), extractedOptions);
    if (!info.hasStart && updateOnly) {
        return getResult({ transformed: false, reason: 'update only' });
    }
    const _mode = mode || 'github.com';
    const _entryPrefix = entryPrefix || '-';
    // only limit *HTML* headings by default
    // eslint-disable-next-line no-magic-numbers
    const maxHeaderLevelHtml = maxHeaderLevel || 4;
    // eslint-disable-next-line no-magic-numbers
    const currentToc = info.hasStart && lines.slice(info.startIdx, info.endIdx + 1).join('\n');
    const linesToToc = exports.getLinesToToc(lines, currentToc, info, processAll);
    const headers = exports.getMarkdownHeaders(linesToToc, maxHeaderLevel).concat(get_html_headers_1.getHtmlHeaders(linesToToc, maxHeaderLevelHtml));
    headers.sort((header1, header2) => header1.line - header2.line);
    const allHeaders = exports.countHeaders(headers, _mode, moduleName);
    const lowestRank = Math.min(...allHeaders.map(header => header.rank));
    const linkedHeaders = allHeaders.map(header => addAnchor(_mode, moduleName, header));
    const inferredTitle = linkedHeaders.length ? determineTitle(title, isNotitle, isFolding, lines, info, startSection, exports.matchesEnd(options.checkClosingComments)) : '';
    // 4 spaces required for proper indention on Bitbucket and GitLab
    const indentation = (_mode === 'bitbucket.org' || _mode === 'gitlab.com') ? '    ' : '  ';
    const toc = buildToc(isCustomMode, inferredTitle, linkedHeaders, lowestRank, customTemplate, itemTemplate, separator, indentation, _entryPrefix, footer);
    const wrappedToc = (openingComment !== null && openingComment !== void 0 ? openingComment : __1.OPENING_COMMENT) + params_1.getParamsSection(extractedOptions) + '\n' + wrapToc(toc, inferredTitle, isFolding) + '\n' + (closingComment !== null && closingComment !== void 0 ? closingComment : __1.CLOSING_COMMENT);
    if (currentToc === wrappedToc) {
        return getResult({ transformed: false, reason: 'not updated' });
    }
    return getResult({
        transformed: true,
        result: {
            data: update_section_1.default(lines.join('\n'), wrappedToc, exports.matchesStart(options.checkOpeningComments), exports.matchesEnd(options.checkClosingComments), true),
            toc,
            wrappedToc,
        },
    });
};
exports.transform = transform;
exports.default = exports.transform;
