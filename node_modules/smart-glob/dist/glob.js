"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGlobsFromGitignore = exports.memoizedGlob = exports.globSync = exports.glob = void 0;
var tslib_1 = require("tslib");
var fs_1 = tslib_1.__importStar(require("fs"));
var globalyzer_1 = tslib_1.__importDefault(require("globalyzer"));
var globrex_1 = tslib_1.__importDefault(require("globrex"));
var uniq_1 = tslib_1.__importDefault(require("lodash/uniq"));
var memoizee_1 = tslib_1.__importDefault(require("memoizee"));
var path_1 = tslib_1.__importStar(require("path"));
var slash_1 = tslib_1.__importDefault(require("slash"));
var support_1 = require("./support");
var isHidden = /(^|[\\\/])\.[^\\\/\.]/g;
var CACHE = {};
function walk(output, prefix, lexer, opts, dirname, level, ignore, globsIgnore) {
    if (dirname === void 0) { dirname = ''; }
    if (level === void 0) { level = 0; }
    if (ignore === void 0) { ignore = []; }
    if (globsIgnore === void 0) { globsIgnore = []; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var rgx, dir, files, dot, includeDirs, filesOnly, i, len, file, fullpath, relpath, stats, isMatch;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    rgx = lexer.segments[level];
                    dir = path_1.resolve(opts.cwd, prefix, dirname);
                    return [4 /*yield*/, fs_1.default.promises.readdir(dir)];
                case 1:
                    files = _b.sent();
                    dot = opts.dot, includeDirs = opts.includeDirs;
                    filesOnly = !includeDirs;
                    i = 0, len = files.length;
                    _b.label = 2;
                case 2:
                    if (!(i < len)) return [3 /*break*/, 5];
                    fullpath = path_1.join(dir, (file = files[i]));
                    relpath = dirname ? path_1.join(dirname, file) : file;
                    if (!dot && isHidden.test(relpath))
                        return [3 /*break*/, 4];
                    isMatch = lexer.regex.test(relpath);
                    if ((stats = CACHE[relpath]) === void 0) {
                        CACHE[relpath] = stats = fs_1.lstatSync(fullpath);
                    }
                    if (!stats.isDirectory()) {
                        isMatch && output.push(path_1.relative(opts.cwd, fullpath));
                        return [3 /*break*/, 4];
                    }
                    // console.log(basename(relpath))
                    if (ignore && ignore.includes(path_1.basename(relpath))) {
                        return [3 /*break*/, 4];
                    }
                    if ((globsIgnore === null || globsIgnore === void 0 ? void 0 : globsIgnore.length) &&
                        globsIgnore.some(function (toIgnore) { return toIgnore.test(relpath); })) {
                        return [3 /*break*/, 4];
                    }
                    if (rgx && !rgx.test(file))
                        return [3 /*break*/, 4];
                    !filesOnly && isMatch && output.push(path_1.join(prefix, relpath));
                    return [4 /*yield*/, walk(output, prefix, lexer, opts, relpath, rgx && rgx.toString() !== lexer.globstar && level + 1, ignore, globsIgnore)];
                case 3:
                    _b.sent();
                    _b.label = 4;
                case 4:
                    i++;
                    return [3 /*break*/, 2];
                case 5: return [2 /*return*/];
            }
        });
    });
}
function walkSync(output, prefix, lexer, opts, dirname, level, ignore, globsIgnore) {
    if (dirname === void 0) { dirname = ''; }
    if (level === void 0) { level = 0; }
    if (ignore === void 0) { ignore = []; }
    if (globsIgnore === void 0) { globsIgnore = []; }
    var rgx = lexer.segments[level];
    var dir = path_1.resolve(opts.cwd, prefix, dirname);
    var files = fs_1.default.readdirSync(dir);
    var dot = opts.dot, includeDirs = opts.includeDirs;
    var i = 0, len = files.length, file;
    var fullpath, relpath, stats, isMatch;
    for (; i < len; i++) {
        fullpath = path_1.join(dir, (file = files[i]));
        relpath = dirname ? path_1.join(dirname, file) : file;
        if (!dot && isHidden.test(relpath))
            continue;
        isMatch = lexer.regex.test(relpath);
        if ((stats = CACHE[relpath]) === void 0) {
            CACHE[relpath] = stats = fs_1.lstatSync(fullpath);
        }
        if (!stats.isDirectory()) {
            isMatch && output.push(path_1.relative(opts.cwd, fullpath));
            continue;
        }
        // console.log(basename(relpath))
        if (ignore && ignore.includes(path_1.basename(relpath))) {
            continue;
        }
        if ((globsIgnore === null || globsIgnore === void 0 ? void 0 : globsIgnore.length) &&
            globsIgnore.some(function (toIgnore) { return toIgnore.test(relpath); })) {
            continue;
        }
        if (rgx && !rgx.test(file))
            continue;
        includeDirs && isMatch && output.push(path_1.join(prefix, relpath));
        walkSync(output, prefix, lexer, opts, relpath, rgx && rgx.toString() !== lexer.globstar && level + 1, ignore, globsIgnore);
    }
}
/**
 * Find files using bash-like globbing.
 * All paths are normalized compared to node-glob.
 * @param {String} str Glob string
 * @param {String} [options.cwd='.'] Current working directory
 * @param {Boolean} [options.dot=false] Include dotfile matches
 * @param {Boolean} [options.absolute=false] Return absolute paths
 * @param {Boolean} [options.filesOnly=true] Do not include folders if true
 * @param {Boolean} [options.flush=false] Reset cache object
 * @returns {Array} array containing matching files
 */
function glob(str, opts) {
    if (opts === void 0) { opts = {}; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var glob, _b, ignore, gitignore, resolved, dirent, matches, globrexPath, _c, ignoreGlobs, globsIgnore;
        return tslib_1.__generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    if (!str)
                        return [2 /*return*/, []];
                    str = path_1.normalize(str);
                    str = slash_1.default(str);
                    glob = globalyzer_1.default(str);
                    _b = opts.ignore, ignore = _b === void 0 ? [] : _b, gitignore = opts.gitignore;
                    if (gitignore) {
                        ignore = tslib_1.__spreadArrays(ignore, exports.getGlobsFromGitignore());
                    }
                    ignore = uniq_1.default(ignore);
                    opts.cwd = opts.cwd || '.';
                    if (!glob.isGlob) {
                        try {
                            resolved = path_1.resolve(opts.cwd, str);
                            dirent = fs_1.default.statSync(resolved);
                            if (!opts.includeDirs && !dirent.isFile())
                                return [2 /*return*/, []];
                            return [2 /*return*/, opts.absolute ? [resolved] : [str]];
                        }
                        catch (err) {
                            if (err.code != 'ENOENT')
                                throw err;
                            return [2 /*return*/, []];
                        }
                    }
                    if (opts.flush)
                        CACHE = {};
                    matches = [];
                    globrexPath = globrex_1.default(glob.glob, tslib_1.__assign({}, support_1.GLOBREX_OPTIONS)).path;
                    // @ts-ignore
                    globrexPath.globstar = globrexPath.globstar.toString();
                    _c = opts.ignoreGlobs, ignoreGlobs = _c === void 0 ? [] : _c;
                    globsIgnore = ignoreGlobs.map(function (x) {
                        return globrex_1.default(x, tslib_1.__assign({}, support_1.GLOBREX_OPTIONS)).path.regex;
                    });
                    return [4 /*yield*/, walk(matches, glob.base, globrexPath, opts, '.', 0, ignore, globsIgnore)];
                case 1:
                    _d.sent();
                    if (opts.absolute) {
                        matches = matches.map(function (x) { return path_1.default.join(opts.cwd, x); });
                    }
                    if (opts.alwaysReturnUnixPaths) {
                        matches = matches.map(slash_1.default);
                    }
                    return [2 /*return*/, matches];
            }
        });
    });
}
exports.glob = glob;
function globSync(str, opts) {
    if (opts === void 0) { opts = {}; }
    if (!str)
        return [];
    str = path_1.normalize(str);
    str = slash_1.default(str);
    var glob = globalyzer_1.default(str);
    var _b = opts.ignore, ignore = _b === void 0 ? [] : _b, gitignore = opts.gitignore;
    if (gitignore) {
        ignore = tslib_1.__spreadArrays(ignore, exports.getGlobsFromGitignore());
    }
    ignore = uniq_1.default(ignore);
    opts.cwd = opts.cwd || '.';
    if (!glob.isGlob) {
        try {
            var resolved = path_1.resolve(opts.cwd, str);
            var dirent = fs_1.default.statSync(resolved);
            if (!opts.includeDirs && !dirent.isFile())
                return [];
            return opts.absolute ? [resolved] : [str];
        }
        catch (err) {
            if (err.code != 'ENOENT')
                throw err;
            return [];
        }
    }
    if (opts.flush)
        CACHE = {};
    var matches = [];
    var globrexPath = globrex_1.default(glob.glob, tslib_1.__assign({}, support_1.GLOBREX_OPTIONS)).path;
    // @ts-ignore
    globrexPath.globstar = globrexPath.globstar.toString();
    var _c = opts.ignoreGlobs, ignoreGlobs = _c === void 0 ? [] : _c;
    var globsIgnore = ignoreGlobs.map(function (x) {
        return globrex_1.default(x, tslib_1.__assign({}, support_1.GLOBREX_OPTIONS)).path.regex;
    });
    walkSync(matches, glob.base, globrexPath, opts, '.', 0, ignore, globsIgnore);
    if (opts.absolute) {
        matches = matches.map(function (x) { return path_1.default.join(opts.cwd, x); });
    }
    if (opts.alwaysReturnUnixPaths) {
        matches = matches.map(slash_1.default);
    }
    return matches;
}
exports.globSync = globSync;
exports.memoizedGlob = memoizee_1.default(glob, {
    promise: true,
    normalizer: function (args) {
        // args is arguments object as accessible in memoized function
        return args[0] + JSON.stringify(args[1]);
    },
});
var getGlobsFromGitignore = function (data) {
    if (data === void 0) { data = ''; }
    try {
        data = data || fs_1.default.readFileSync('.gitignore', { encoding: 'utf8' });
        return data
            .split(/\r?\n/)
            .filter(function (line) { return !/^\s*$/.test(line) && !/^\s*#/.test(line); })
            .map(function (line) { return line.trim().replace(/^\/+|\/+$/g, ''); });
    }
    catch (_a) {
        return [];
    }
};
exports.getGlobsFromGitignore = getGlobsFromGitignore;
//# sourceMappingURL=glob.js.map