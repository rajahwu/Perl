"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.gitPathsSync = exports.gitPaths = exports.globWithGitSync = exports.globWithGit = void 0;
var tslib_1 = require("tslib");
var child_process_1 = require("child_process");
var globrex_1 = tslib_1.__importDefault(require("globrex"));
var difference_1 = tslib_1.__importDefault(require("lodash/difference"));
var path_1 = tslib_1.__importDefault(require("path"));
var promisify_child_process_1 = require("promisify-child-process");
// import fastGlob from 'fast-glob'
var slash_1 = tslib_1.__importDefault(require("slash"));
var glob_1 = require("./glob");
var support_1 = require("./support");
function normalizeGlobStr(globStr) {
    globStr = path_1.default.normalize(globStr);
    globStr = slash_1.default(globStr);
    return globStr;
}
function filterPathsByGlob(paths, globStr, opts) {
    var cwd = path_1.default.resolve(opts.cwd || '.');
    if (path_1.default.isAbsolute(globStr)) {
        paths = paths.map(function (p) { return path_1.default.join(cwd, p); });
    }
    globStr = slash_1.default(globStr);
    support_1.debug({ globStr: globStr });
    var globRegex = globrex_1.default(globStr, support_1.GLOBREX_OPTIONS).path.regex;
    support_1.debug("using regex " + globRegex);
    support_1.debug("starting filtering paths");
    var filteredPaths = paths.filter(function (p) { return globRegex.test(p); });
    var _a = opts.ignoreGlobs, ignoreGlobs = _a === void 0 ? [] : _a;
    support_1.debug("removing ignored paths");
    var ignoreRegexes = ignoreGlobs.map(function (x) {
        x = slash_1.default(x);
        return globrex_1.default(x, tslib_1.__assign({}, support_1.GLOBREX_OPTIONS)).path.regex;
    });
    if (ignoreRegexes === null || ignoreRegexes === void 0 ? void 0 : ignoreRegexes.length) {
        filteredPaths = filteredPaths.filter(function (x) { return !ignoreRegexes.some(function (toIgnore) { return toIgnore.test(x); }); });
    }
    if (opts.absolute && !path_1.default.isAbsolute(globStr)) {
        support_1.debug("making paths absolute");
        // filteredPaths = filteredPaths.map((p) => resolve(p))
        filteredPaths = filteredPaths.map(function (p) { return path_1.default.join(cwd, p); });
    }
    if (!opts.absolute && path_1.default.isAbsolute(globStr)) {
        support_1.debug("making paths relative");
        // filteredPaths = filteredPaths.map((p) => resolve(p))
        filteredPaths = filteredPaths.map(function (p) { return path_1.default.relative(cwd, p); });
    }
    if (opts.alwaysReturnUnixPaths) {
        return filteredPaths.map(slash_1.default);
    }
    return filteredPaths;
}
function globWithGit(globStr, opts) {
    if (opts === void 0) { opts = {}; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var cwd, paths, e_1;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 2, , 3]);
                    if (!globStr)
                        return [2 /*return*/, []];
                    globStr = normalizeGlobStr(globStr);
                    support_1.debug("getting paths with git");
                    cwd = path_1.default.resolve(opts.cwd || '.');
                    return [4 /*yield*/, gitPaths({
                            cwd: cwd,
                            gitFlags: opts.gitFlags,
                            gitignore: opts.gitignore,
                        })];
                case 1:
                    paths = _a.sent();
                    return [2 /*return*/, filterPathsByGlob(paths, globStr, opts)];
                case 2:
                    e_1 = _a.sent();
                    console.error(e_1, 'could not use git to get globbed files, traversing fs tree');
                    return [2 /*return*/, glob_1.glob(globStr, tslib_1.__assign({}, opts))];
                case 3: return [2 /*return*/];
            }
        });
    });
}
exports.globWithGit = globWithGit;
function globWithGitSync(globStr, opts) {
    if (opts === void 0) { opts = {}; }
    try {
        if (!globStr)
            return [];
        globStr = normalizeGlobStr(globStr);
        support_1.debug("getting paths with git");
        var cwd = path_1.default.resolve(opts.cwd || '.');
        var paths = gitPathsSync({
            cwd: cwd,
            gitFlags: opts.gitFlags,
            gitignore: opts.gitignore,
        });
        return filterPathsByGlob(paths, globStr, opts);
    }
    catch (e) {
        console.error(e, "could not use git to search files with glob " + globStr + ", traversing fs tree");
        return glob_1.globSync(globStr, tslib_1.__assign({}, opts));
    }
}
exports.globWithGitSync = globWithGitSync;
// get paths with git, paths are always relative to cwd
// in windows paths use the \\ path delimiter
function gitPaths(_a) {
    var _b = _a.cwd, cwd = _b === void 0 ? '.' : _b, gitFlags = _a.gitFlags, _c = _a.gitignore, gitignore = _c === void 0 ? false : _c;
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var maxBuffer, gitCommand, _d, stdout, toRemove, paths, pathsToRemove, resultPaths;
        return tslib_1.__generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    cwd = path_1.default.resolve(cwd);
                    maxBuffer = 1024 * 10000000;
                    gitCommand = getGitCommand({ gitignore: gitignore, gitFlags: gitFlags });
                    return [4 /*yield*/, Promise.all([
                            promisify_child_process_1.exec(gitCommand, {
                                cwd: cwd,
                                maxBuffer: maxBuffer,
                            }),
                            promisify_child_process_1.exec("git ls-files --deleted", {
                                cwd: cwd,
                                maxBuffer: maxBuffer,
                            }),
                        ])
                        // console.error(stderr.toString())
                    ];
                case 1:
                    _d = _e.sent(), stdout = _d[0].stdout, toRemove = _d[1].stdout;
                    paths = makeList(stdout.toString());
                    pathsToRemove = makeList(toRemove.toString());
                    resultPaths = difference_1.default(paths, pathsToRemove).map(path_1.default.normalize);
                    support_1.debug(resultPaths.slice(0, 5) + '...');
                    return [2 /*return*/, resultPaths];
            }
        });
    });
}
exports.gitPaths = gitPaths;
function gitPathsSync(_a) {
    var _b = _a.cwd, cwd = _b === void 0 ? '.' : _b, gitFlags = _a.gitFlags, _c = _a.gitignore, gitignore = _c === void 0 ? false : _c;
    cwd = path_1.default.resolve(cwd);
    var maxBuffer = 1024 * 10000000;
    var gitCommand = getGitCommand({ gitignore: gitignore, gitFlags: gitFlags });
    var _d = [
        child_process_1.execSync(gitCommand, {
            cwd: cwd,
            maxBuffer: maxBuffer,
        }),
        child_process_1.execSync("git ls-files --deleted", {
            cwd: cwd,
            maxBuffer: maxBuffer,
        }),
    ], stdout = _d[0], toRemove = _d[1];
    // console.error(stderr.toString())
    var paths = makeList(stdout.toString());
    var pathsToRemove = makeList(toRemove.toString());
    var resultPaths = difference_1.default(paths, pathsToRemove).map(path_1.default.normalize);
    support_1.debug(resultPaths.slice(0, 5) + '...');
    return resultPaths;
}
exports.gitPathsSync = gitPathsSync;
function getGitCommand(_a) {
    var _b = _a.gitFlags, gitFlags = _b === void 0 ? '--cached --others' : _b, gitignore = _a.gitignore;
    if (gitignore) {
        gitFlags = gitFlags + ' --exclude-standard';
    }
    return "git ls-files " + gitFlags;
}
function makeList(stdout) {
    var paths = stdout
        .toString()
        .split(/\r?\n/)
        .map(function (x) { return x.trim(); })
        .filter(Boolean);
    return paths;
}
//# sourceMappingURL=git.js.map